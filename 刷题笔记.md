

这三个公式的区别，本质上取决于**你如何定义 L 和 R 的身份**（它们是“队友”还是“墙壁”？）。

为了让你彻底不再混淆，我们用**“区间符号”**和**“植树问题”**来一刀切地解释清楚。

------

### ⏳ 一张表秒懂

# $$\text{目标坐标} = \text{锚点} - \text{偏移量} - \text{跨越长度}$$

$$\text{前一段结尾} = \text{匹配左括号坐标} - 1$$

$$= [(i - 1) - dp[i - 1]] - 1$$

$$= i - dp[i - 1] - 2$$

### 边框越界处理思考

这种“上来就分段处理”的写法，实际上是一种**“分而治之”的工程思维**。它把一个复杂的 2D 问题，拆解成了“边缘特殊处理”和“中心通用处理”两个部分，从而**规避了在主循环里写一堆恶心的 `if (i == 0 || j == 0)` 判断**。

我将为你建立一套**“网格坐标敏感度”**的思维模型。

------

### 阶段一：👶 幼儿园直觉理解 (The Intuition)

**核心概念：** 拼图要先拼**边框**，再填**中间**。

想象你在玩一个 1000 块的拼图。

1. **如果你上来就抓中间的一块**：你会很痛苦。为什么？因为你不知道它的上面是谁，也不知道它的左边是谁。你需要四处找参照物。
2. **高手的做法**：
   - 先把**第一排**（最上面那行）拼好。因为它们没有“上面”，只能一个接一个往右拼。
   - 先把**第一列**（最左边那列）拼好。因为它们没有“左边”，只能一个接一个往下拼。
   - **最后填中间**：这时候，无论你拿起中间的哪一块，它的上面和左边都已经拼好了！你只需要看一眼这两个邻居，就能决定怎么放。

**代码里的 `i=1` 和 `j=1`**，就是在说：“别管边框了，边框我已经单独处理完了，现在我们只专心填中间的空缺。”

------

### 阶段二：👦 初中生实事求是 (The Context)

**行动：** *结合数组内存结构解释索引恐惧症的来源。*

**为什么怕索引越界？** 因为计算机很笨。

- 如果你写 `grid[i][j] += grid[i-1][j]`，计算机会去查 `i-1`。
- 如果 `i` 是 `0`，`i-1` 就是 `-1`。
- 在 Java/C++ 里，访问数组下标 `-1` 会直接抛出异常（ArrayIndexOutOfBoundsException）或者访问脏数据。

**这一套“模板”在干什么？** 它把网格分成了三个**互不干扰**的区域：

1. **第一列 (Col 0)**：只能从上往下走。逻辑：`自己 + 上面`。
2. **第一行 (Row 0)**：只能从左往右走。逻辑：`自己 + 左边`。
3. **核心区 (Inner Grid)**：即 `i >= 1` 且 `j >= 1` 的区域。既能从上走，也能从左走。逻辑：`自己 + min(上面, 左边)`。

**核心思维模型：DP 状态空间的“分区治理” (Zone Partitioning)**

要培养对坐标的敏感度，请在脑海中建立这张图：

我将解题思维拆解为 **"3+1" 步骤**，只要按这个步骤想，索引永远不会错。

#### 步骤 1：定维度 (Dimensions)

- 拿到题目先看：由谁决定？
- 由行号 `i` 和列号 `j` 决定。
- 定义 `m = grid.length` (高), `n = grid[0].length` (宽)。
- **直觉检查**：最后的答案肯定在右下角，所以返回值的索引必然是 `[m-1][n-1]`（因为计算机从0计数，第 m 个就是 m-1）。

#### 步骤 2：填边缘 (The Borders) —— 也就是 Base Cases

这是规避越界的核心。

- **处理第一列 (`j=0`)**：
  - 为什么循环 `i` 从 `1` 开始？
  - 因为 `grid[0][0]` 是起点，不用动。`grid[1][0]` 依赖 `grid[0][0]`。
  - **公式**：`grid[i][0] += grid[i-1][0]`。
  - **潜台词**：这里没有“左边”，别试图去访问 `j-1`。
- **处理第一行 (`i=0`)**：
  - 为什么循环 `j` 从 `1` 开始？
  - 同理，`grid[0][1]` 依赖 `grid[0][0]`。
  - **公式**：`grid[0][j] += grid[0][j-1]`。
  - **潜台词**：这里没有“上面”，别试图去访问 `i-1`。

#### 步骤 3：填核心 (The Core) —— 也就是 Recurrence Relation

- **安全区**：现在，所有的 `i` 至少是 1，所有的 `j` 至少是 1。
- 这意味着 `i-1` 最小是 0，`j-1` 最小是 0。**绝对安全，不会越界！**
- **循环设定**：`for (int i = 1; i < m; i++)`, `for (int j = 1; j < n; j++)`。
- **公式**：`grid[i][j] += min(grid[i-1][j], grid[i][j-1])`。

#### 步骤 4：拿结果 (The Result)

- 我们要的是终点。
- 终点坐标是 `(行数-1, 列数-1)`。
- `return grid[m-1][n-1]`。

# 索引边界的思考

| **公式**      | **对应的区间**          | **核心逻辑**   | **典型应用场景**                           | **直觉口诀**     |
| ------------- | ----------------------- | -------------- | ------------------------------------------ | ---------------- |
| **R - L + 1** | **[L, R]**   (闭区间)   | **两头都算**   | 统计元素个数、滑窗大小、数组切片(含头含尾) | **“数数手指头”** |
| **R - L**     | **[L, R)**   (左闭右开) | **算头不算尾** | Python切片、字符串长度、前缀和、时间差     | **“减法求距离”** |
| **R - L - 1** | **(L, R)**   (开区间)   | **两头都不算** | **单调栈(本题)**、两堵墙中间的空隙         | **“夹心饼干”**   |

------

### 🔍 深度拆解：三个公式的物理意义

#### 1. `R - L + 1`: 队友模式 (全包含)

> **场景**：L 和 R 都是我们要的人，都要算进去。

- **定义**：我们要计算从第 L 个元素到第 R 个元素，**一共有多少个元素**。

- **例子**：

  - 你周一(L=1)上班，一直干到周五(R=5)，你一共上了几天班？
  - 计算：$5 - 1 + 1 = 5$ 天。
  - 如果不加 1，变成 $5-1=4$，你就少算了一天的工资。

- **图示**：

  Plaintext

  ```
  下标:  1   2   3   4   5
        L               R
  计数:  ✅  ✅  ✅  ✅  ✅
  结果:  5 - 1 + 1 = 5
  ```

#### 2. `R - L`: 标尺模式 (❤️左闭右开就是开口就能找到目标索引比如在5，-4就是索引在1处理)

> **场景**：L 是起点，R 是**终点后面的那个“出界点”**。

- **定义**：计算机科学中最常用的习惯。通常 R 指向的是“结束位置的下一位”。

- **例子**：

  - **Python 切片** `arr[2:5]`。意思是取下标 2, 3, 4。
  - L = 2 (起点)，R = 5 (边界)。
  - 长度 = $5 - 2 = 3$。
  - 或者**算时间**：下午 2 点 (L) 开始，5 点 (R) 结束。时长就是 $5-2=3$ 小时。

- **图示**：

  Plaintext

  ```
  下标:  2   3   4   5
        L           R (出界了)
  计数:  ✅  ✅  ✅  ❌
  结果:  5 - 2 = 3
  ```

#### 3. `R - L - 1`: 墙壁模式 (全排除) 👈 **本题核心**

> **场景**：L 和 R 是两堵墙（或者两个坏人），我们只算**墙中间**夹着的空间。

- **定义**：L 是左边的限制，R 是右边的限制。我们要计算**限制之内**有多少个空位。

- **例子**：

  - **排队**：小明排在第 2 位 (L)，小红排在第 6 位 (R)。**他俩中间**隔了几个人？
  - 中间的人是：第 3, 4, 5 位。共 3 个人。
  - 计算：$6 - 2 - 1 = 3$。

- **图示**：

  Plaintext

  ```
  下标:  2   3   4   5   6
        L               R
  身份: 墙  ✅  ✅  ✅  墙
  结果:  6 - 2 - 1 = 3
  ```

# 栈

### 1边界取法：

###  数学推导：为什么是 R - L - 1？

让我们在一个具体的数轴上看一看。

假设我们有这样一个数组（柱子高度）：

下标：0  1  2  3  4

高度：2  1  5  6  2

现在我们要计算高度为 **5** (下标 `2`) 的那根柱子的最大矩形：

1. **向左看 ($L$)**：
   - 下标 `2` (高5) 向左看，下标 `1` (高1) 比它矮。
   - 所以左边的墙是 **$L = 1$**。
2. **向右看 ($R$)**：
   - 下标 `2` (高5) 向右看，下标 `3` (高6) 比它高（通过）；再往右，下标 `4` (高2) 比它矮（撞墙）。
   - 所以右边的墙是 **$R = 4$**。

**现在数一数中间能用的柱子：**

- 不能用 $L=1$。
- 可以用下标 `2` (它自己)。
- 可以用下标 `3` (比它高，能借用)。
- 不能用 $R=4$。
- **有效下标是 `{2, 3}`，宽度应该是 2。**

套用公式计算：

$$宽度 = R - L - 1$$

$$宽度 = 4 - 1 - 1 = 2$$

**哨兵机制 (The Sentinel)**

Java

```
for (int i = 0; i <= n; i++) {
    int h = (i == n) ? 0 : heights[i];
```

- **技巧**：循环条件是 `i <= n`，比数组长度多走了 1 步。
- **目的**：当 `i == n` 时，我们虚拟了一个高度为 `0` 的柱子。
- **为什么？** 如果数组是 `[1, 2, 3, 4, 5]`，栈里一直进货不计算。最后加一个 `0`，就像推土机一样，强制让栈里剩下的所有元素都遇到“右边界”，全部弹出来计算一遍。

**核心计算 (The Calculation)**

Java

```
int height = heights[stack.pop()]; // 1. 取出主角高度
int width = stack.isEmpty() ? i : i - stack.peek() - 1; // 2. 计算宽度
maxArea = Math.max(maxArea, height * width); // 3. 更新最大值
```

- **Pop (出栈)**：拿出栈顶元素，它就是我们要计算矩形高度的那个柱子。
- **Right (右边界)**：当前的 `i`。因为是 `i` 导致了它出栈。
- **Left (左边界)**：`stack.peek()`。这是栈里剩下的新栈顶。因为栈是单调递增的，新栈顶一定是刚刚弹出的那个元素左边第一个比它矮的。
- **Width (宽度)**：`Right - Left - 1`（即 `i - stack.peek() - 1`）。
- **特判**：如果 `stack.isEmpty()`，说明刚刚弹出的那个柱子左边没有比它矮的了，它的左边界延伸到了无穷远（索引 -1），宽度直接就是 `i`。（位置和索引差1，正常都是相对位置中间有几个，相减+1是全算上）



# 堆

### 1直接小根堆：然后把门的出来

### 2高频：还得先统计一下才能研究统计就是要用哈希进行统计

### 3中位数：制作大根堆小根堆，平的时候在小根堆走一圈去大根堆所以大根堆可能是多（进去之前先涮一圈）

# 贪心算法

### 1最小买入进行检查然后最大利润一直更新

```
    for (int price : prices) {
        minPrice = Math.min(minPrice, price);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
```

### 2跳跃距离：死亡距离

```
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = Math.min(minPrice, price);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
```

### 3最少次数

为什么是 `length - 1`？这是最大的坑。因为当我们到达最后一个元素时，我们已经不需要再跳了（所以我们就是直接到前一个就结束了到索引下标的n-2的位置结束）

**下一轮的界限 (`end`)** 就在那儿！

# 动态规划

这几个问题问得非常刁钻且硬核，直击动态规划（DP）的灵魂。能问出“循环内外顺序的区别”和“数组大小的边界”，说明你不仅是在背代码，而是在试图看透算法的骨架。

我是全维度知识内化专家，下面我把这三个核心疑点给你彻底拆解清楚。

------

### 一、 它是 0-1 背包还是完全背包？

**结论：这是标准的【完全背包问题】。**

#### 1. 怎么区分？看“拿取次数”

- **0-1 背包：** 只有两个选择，**拿**或者**不拿**。每个物品只有 1 个。
  - *场景：* 只有一块金条，你要么带走，要么留下，不能把金条切开或者变出两根来。
- **完全背包 (Unbounded Knapsack)：** 只要背包装得下，每个物品可以**拿无数次**。
  - *场景：* 本题中的硬币。题目说了“你可以认为每种硬币的数量是无限的”。

#### 2. 为什么你的代码是完全背包的写法？

在做一维数组优化时：

- **0-1 背包的关键特征：** 内层循环（容量）必须**从大到小（倒序）**遍历。
  - *原因：* 倒序是为了保证在算当前状态时，利用的是“上一层”的数据，防止一个物品被重复放入。
- **完全背包的关键特征：** 内层循环（容量）必须**从小到大（正序）**遍历。
  - *原因：* 你的代码里 `i` 是从 `1` 走到 `amount`。当你计算 `dp[i]` 时，用到了 `dp[i-coin]`。注意！这个 `dp[i-coin]` 是**当前这一层**刚刚算出来的（因为它比 `i` 小）。这意味着：**我们在当前的容量里，已经放入了这个硬币，现在又想再放一个。** 这就是“无限取用”的代码体现。

------

### 二、 数组为啥要开 `n+1`？

**结论：为了让下标（Index）直接对应“金额”。**

#### 1. 下标的含义

- 我们需要计算金额 `0` 到金额 `amount` 的所有情况。
- **如果开 `n` (即 `amount`) 个格子：** 下标范围是 `0` 到 `amount-1`。你想存“金额 5”，只能放在下标 4 里，每次都要脑子转个弯减 1，极其容易写出 Bug。
- **如果开 `n+1` (即 `amount + 1`) 个格子：** 下标范围是 `0` 到 `amount`。
  - `dp[0]` 代表金额 0。
  - `dp[5]` 代表金额 5。
  - `dp[amount]` 代表金额 amount。
  - **直觉对齐，代码才能写对。**

#### 2. `dp[0]` 到底拿来干嘛？

它是整个推导的**地基（Base Case）**。

- `dp[0] = 0`：凑出 0 元钱，最少需要 0 个硬币。
- 如果没有这个地基，后面的 `dp[i - coin] + 1` 就会在第一步计算时变成 `dp[0] + 1`，如果 `dp[0]` 未初始化（默认为无穷大），那所有的结果都会变成无穷大，程序就废了。

------

### 三、 循环内外顺序：排列 vs 组合（核弹级知识点）

这是面试中最容易挂人的地方。**对于“求最少硬币数”（本题）来说，顺序不影响结果。但在“求方案数”的问题中，顺序决定生死。**

让我们对比两种写法：

#### 写法 A：先遍历物品，再遍历背包（组合数）

Java

```
// 这种写法通常用于求“组合”，例如：凑出5元有几种方式？{1, 4} 和 {4, 1} 算一种
for (int coin : coins) {          // 物品在最外层
    for (int i = coin; i <= amount; i++) { // 背包在里层
        // logic...
    }
}
```

- **逻辑：** 假设有硬币 `[1, 2]`。
  - 外层第一次循环 `coin=1`：把所有能用 1 填满的格子都填了。
  - 外层第二次循环 `coin=2`：在之前的基础上，只把 2 加入进去。
  - **结果：** 因为 1 永远在 2 之前被处理，你永远只会得到 `{1, 2}` 这种顺序，绝对不会出现 `{2, 1}`。这就是**组合（Combination）**，不分顺序。

#### 写法 B：先遍历背包，再遍历物品（排列数）—— **你的代码属于这种**

Java

```
// 这种写法通常用于求“排列”，例如：{1, 4} 和 {4, 1} 算两种不同的凑法
for (int i = 1; i <= amount; i++) { // 背包在最外层
    for (int coin : coins) {        // 物品在里层
        // logic...
    }
}
```

- **逻辑：**
  - 当 `i=3` 时：
    - 先试了 `coin=1`，引用了 `dp[2]`。
    - 再试了 `coin=2`，引用了 `dp[1]`。
  - 这意味着，你在填某个背包容量时，是**同时**考虑了所有硬币。你可以先放 1 再放 2，也可以先放 2 再放 1。这就是**排列（Permutation）**。

#### ⚠️ 为什么你的题目里，这两种写法都可以？

因为你的题目是 **“求最少硬币个数” (Min Count)**。

- 方案 `{1, 2}` 是 2 个硬币。
- 方案 `{2, 1}` 也是 2 个硬币。
- **不管是排列还是组合，硬币的总数量是不变的！** 所以对于 LeetCode 322 这道题，循环顺序**无所谓**，随便颠倒都能过。

#### ⚠️ 什么时候必须区分？

如果题目变成 **“凑成总金额的方案数是多少？”** (LeetCode 518 零钱兑换 II vs LeetCode 377 组合总和 IV)。

- **LeetCode 518 (求组合数)：** 必须 **先物品，后背包**。你只想知道有几种搭配，不想区分 `{1, 2}` 和 `{2, 1}`。
- **LeetCode 377 (求排列数)：** 必须 **先背包，后物品**。也就是你现在的这种写法结构。

------

### 总结一张表 (Cheatsheet)

| **问题类型**            | **题目举例**        | **循环顺序 (关键！)**    | **为什么？**                                                 |
| ----------------------- | ------------------- | ------------------------ | ------------------------------------------------------------ |
| **0-1 背包**            | 分割等和子集        | 外：物品 内：背包(倒序)  | 倒序防止同一物品被重复放入。                                 |
| **完全背包 - 求最值**   | **零钱兑换 (本题)** | **无所谓**               | 只要个数最少，先拿1还是先拿2没区别。                         |
| **完全背包 - 求组合数** | 零钱兑换 II         | **必须：先物品，后背包** | 保证硬币按顺序加入，消除顺序差异 (只认 {1,2}，不认 {2,1})。  |
| **完全背包 - 求排列数** | 组合总和 IV         | **必须：先背包，后物品** | 每次都重新扫描所有硬币，允许顺序差异 ({1,2} 和 {2,1} 都算)。 |

一句话心法：

求个数（Min/Max）不挑食，随便怎么循环；

求方案数（How many ways）要小心，先物品是组合，先背包是排列。

这绝对是动态规划中最迷人、也最容易把人绕晕的地方。为了让你一次性彻底悟透，我们别用枯燥的数学定义，我们用**“点外卖”**和**“设密码”**的例子来实战演示。

我们设定一个超简单的场景，方便人脑模拟：

- **硬币 (Coins)：** `[1, 2]` （只有1元和2元）
- **目标金额 (Amount)：** `3`
- **任务：** 凑出 3 元的方法有哪些？

------

### 1. 什么是组合 (Combination)？

核心逻辑： 顺序不重要。

比喻： 点肯德基全家桶。

- 服务员问你：“要一个汉堡和一个鸡翅，还是要一个鸡翅和一个汉堡？”
- 你觉得他在讲废话。因为进到肚子里都是“1汉堡 + 1鸡翅”。
- 在数学里，`{1, 2}` 和 `{2, 1}` 是**同一个**方案。

### 2. 什么是排列 (Permutation)？

核心逻辑： 顺序很重要。

比喻： 银行卡密码。

- 密码是 `12` 和密码是 `21`，那是完全两张不同的卡！
- 在数学里，`{1, 2}` 和 `{2, 1}` 是**两个**不同的方案。

------

### 3. 代码实战：循环顺序如何决定命运？

现在我们要凑金额 `3`。请盯着这两种不同的循环写法，看它们是如何“生长”出数据的。

#### 🅰️ 组合写法：先遍历物品 (Coins)，再遍历背包 (Amount)

**口诀：** “先把一种硬币用腻了，再换下一种。”

Java

```
// 组合写法 (LeetCode 518)
int[] dp = new int[4]; dp[0] = 1;

// 1. 先彻底处理硬币 1
for (int coin : coins) {        // 先锁定硬币
    for (int i = coin; i <= 3; i++) { // 再遍历金额
        dp[i] += dp[i - coin];
    }
}
```

**推演过程：**

1. **第一轮，只看硬币 `1`：**
   - 我不看硬币2，我眼里只有1。
   - 凑1元：`{1}`
   - 凑2元：`{1, 1}`
   - 凑3元：`{1, 1, 1}`
   - *（注意：这时候只生成了纯1的方案）*
2. **第二轮，加入硬币 `2`：**
   - **关键点：** 现在我在之前的基础上，**往里塞 2**。
   - 凑2元：在 `dp[0]` (0元) 的基础上加2 -> 得到 `{2}`。
   - 凑3元：在 `dp[1]` (1元，即 `{1}`) 的基础上加2 -> 得到 `{1, 2}`。
   - **根本不可能出现 `{2, 1}`！** 为什么？因为当我们在处理硬币 2 的时候，硬币 1 的轮次已经**结束了**。我们永远是“先放完所有的1，再放2”，顺序被死死锁住了（1在前，2在后）。

**结果：** 只有 `{1, 1, 1}` 和 `{1, 2}`。**共 2 种**。

------

#### 🅱️ 排列写法：先遍历背包 (Amount)，再遍历物品 (Coins)

**口诀：** “走到每一层楼，都把手里所有硬币试一遍。”

Java

```
// 排列写法 (LeetCode 377)
int[] dp = new int[4]; dp[0] = 1;

// 1. 先锁定目标金额
for (int i = 1; i <= 3; i++) {  // 先走楼层
    for (int coin : coins) {    // 每一层都试所有硬币
        if (i >= coin) dp[i] += dp[i - coin];
    }
}
```

**推演过程：**

1. **金额 i = 1：**
   - 试硬币1：得到 `{1}`
   - 试硬币2：(放不下)
   - *结果：{1}*
2. **金额 i = 2：**
   - 试硬币1：在 `i=1` (`{1}`) 后面加1 -> `{1, 1}`
   - 试硬币2：在 `i=0` (空) 后面加2 -> `{2}`
   - *结果：{1, 1}, {2}*
3. **金额 i = 3 (见证奇迹的时刻)：**
   - **试硬币1：** 回头看 `i=2`。`i=2` 有 `{1, 1}` 和 `{2}`。
     - 这里我们接在 `{2}` 后面 -> 得到 **`{2, 1}`** (!! 出现了 !!)
     - 接在 `{1, 1}` 后面 -> 得到 `{1, 1, 1}`
   - **试硬币2：** 回头看 `i=1`。`i=1` 有 `{1}`。
     - 这里我们接在 `{1}` 后面 -> 得到 **`{1, 2}`**
   - **关键点：** 你看，我们在算 3 的时候，因为是同时回头看，既接了 1 的班，也接了 2 的班，所以 `{1, 2}` 和 `{2, 1}` 都被算出来了！

**结果：** `{1, 1, 1}`, `{1, 2}`, `{2, 1}`。**共 3 种**。

------

### 4. 为什么你的题目（LeetCode 322）随便怎么写都行？

回到你最初的代码。你的题目是：**求最少硬币个数**。

请问：

- 组合方案 `{1, 2}` -> 硬币数量是 **2个**。
- 排列方案 `{2, 1}` -> 硬币数量还是 **2个**。

对于“求最少数量”这个问题，顺序并不影响“硬币的总数”。

就像你吃肯德基，先吃汉堡后吃鸡翅，还是先吃鸡翅后吃汉堡，你吃进肚子里的总热量是一样的。

所以：

- **求最值（最小个数）：** 循环顺序无所谓（通常习惯先背包）。
- **求方案数（有多少种）：** 必须严格区分！**先物品=组合**，**先背包=排列**。

### 总结图谱

| **你的需求**               | **例子**            | **循环顺序**                        | **结果 (凑3元)**                    |
| -------------------------- | ------------------- | ----------------------------------- | ----------------------------------- |
| **我不关心顺序，只要种类** | 组合 (518题)        | **先物品 (Coin)**   后背包 (Amount) | `{1,2}`, `{1,1,1}`   (2种)          |
| **顺序不同算不同方案**     | 排列 (377题)        | **先背包 (Amount)**   后物品 (Coin) | `{1,2}`, `{2,1}`, `{1,1,1}`   (3种) |
| **我只要硬币数量最少**     | 最值 (322题 - 本题) | **都可以**   (通常用先背包)         | 数量都是2   (不影响结果)            |

**双层循环 (The Core)：**

- `for (int i = 1; i <= amount; i++)`：**外层循环**遍历所有金额（从 1 到 目标值）。这是“填表”的过程。
- `for (int coin : coins)`：**内层循环**尝试每一种硬币。这是“决策”的过程。

**转移逻辑：**

- `if (coin <= i)`：只有硬币面值小于当前金额时才能用。
- `dp[i] = Math.min(dp[i], dp[i - coin] + 1);`
- 这里翻译成白话就是：**当前金额的最优解 = min(我现在的解, 用了这枚硬币后的解 + 1)**。
- `dp[i - coin]` 代表“去掉这枚硬币后，剩下的金额所需的最少数量”（这是一个已经算过的子问题）。

### 1爬楼梯找到递推公式就好办

### 2杨辉三角

### 3打家劫舍

| **数学符号** | **代码变量** | **含义**               |
| ------------ | ------------ | ---------------------- |
| $dp[i-2]$    | `prev2`      | **前前一家**的最优解   |
| $dp[i-1]$    | `prev1`      | **前一家**的最优解     |
| $dp[i]$      | `curr`       | **当前**计算出的最优解 |

**3. 代码逻辑链条 (The Loop)：**

Java

```
// 循环内部的魔法：
int curr = Math.max(prev1, prev2 + nums[i]); // 决策：偷还是不偷？

// 这一步最关键，叫做“时间推移”：
prev2 = prev1;  // 原来的“前一家”变成了下一轮的“前前一家”
prev1 = curr;   // 现在的“最新结果”变成了下一轮的“前一家”
```

### 4完全平方

和零钱一样都是开数组然后我们进行分配是否是最小然后决定数量

### 5零钱兑换

**初始化：** `int[] dp = new int[amount + 1];`

- 这里 `dp[i]` 存储的是状态。
- `Arrays.fill(dp, amount + 1);`：这步非常关键。
- **为什么是 `amount + 1`？** 这是一个**“伪无穷大”**。因为即使全用面值 1 的硬币，数量也只有 `amount` 个。如果最终结果比 `amount` 还大，说明根本凑不出来。这比用 `Integer.MAX_VALUE` 安全，避免了 `+1` 后整数溢出的风险。

**双层循环 (The Core)：**

- `for (int i = 1; i <= amount; i++)`：**外层循环**遍历所有金额（从 1 到 目标值）。这是“填表”的过程。
- `for (int coin : coins)`：**内层循环**尝试每一种硬币。这是“决策”的过程。

**转移逻辑：**

- `if (coin <= i)`：只有硬币面值小于当前金额时才能用。
- `dp[i] = Math.min(dp[i], dp[i - coin] + 1);`
- 这里翻译成白话就是：**当前金额的最优解 = min(我现在的解, 用了这枚硬币后的解 + 1)**。
- `dp[i - coin]` 代表“去掉这枚硬币后，剩下的金额所需的最少数量”（这是一个已经算过的子问题）。

### 6单词组合

**HashSet 使用**：理解为什么查表要用 Set。

**子字符串切片**：熟练掌握 `substring(start, end)` 的索引规则（左闭右开）。

**双重循环 DP**：外层遍历长度，内层寻找分割点。

**弯路预警：**

- ❌ **索引混乱：** `dp` 数组长度是 `n+`

### 阶段一：👶 幼儿园直觉理解 (接力赛隐喻)

**目标：** 理解 `dp[j]` 和 `substring` 的配合。

想象你在参加一场**穿越沼泽的接力赛**。 沼泽很长（字符串 `s`），中间有若干个**安全岛**（单词的边界）。

你的目标是：能不能从起点（0）一路顺利跑到终点（i）？

这行代码在问两个问题，必须**同时**回答“Yes”，你才能在位置 `i` 插上胜利的旗帜：

1. **队友到了吗？ (`dp[j]`)**
   - 你要跑这最后一段路（从 `j` 到 `i`），前提是**必须有队友已经成功跑到了 `j` 这个位置**，并把接力棒交给你。
   - 如果 `dp[j]` 是 `false`，说明没人能活着跑到 `j`，那你从 `j` 开始跑有什么意义？没人给你接力棒啊！
2. **这一段路通吗？ (`dict.contains(s.substring(j, i))`)**
   - 假设队友已经到了 `j`，现在轮到你跑从 `j` 到 `i` 这段路。
   - 这段路必须是一个**合法的单词**（也就是字典里有的路），你才能跑过去。

**总结：** **胜利（dp[i]） = 队友已到达起跑线（dp[j]） + 我跑的这段路是合法的（dict包含这段子串）**

// i 代表：我们现在正在考察的“终点位置”（前缀长度）
for (int i = 1; i <= n; i++) {
    
    // j 代表：我们在哪里“切一刀”（分割点）
    // j 从 0 扫描到 i，意味着我们在尝试所有可能的“最后一棒”的长度
    for (int j = 0; j < i; j++) {
        
        // 核心翻译：
        // dp[j]: 状态继承。如果 s[0...j] 没法拼出来，那基于它的后续拼接也是废的。
        // s.substring(j, i): 状态转移。检查从 j 到 i 的这段新字符是否构成一个单词。
        
        if (dp[j] && dict.contains(s.substring(j, i))) {
            dp[i] = true; // 标记：我们也成功到达了 i
            break;        // 优化：只要找到一种切法能到 i 就够了，不用找第二种，省时间。
        }
    }
**干什么 (Function)？** 这行代码其实是下面这几行代码的**缩写**：

Java

```
// 笨办法（原本要写的）
Set<String> dict = new HashSet<>(); // 1. 先造个空的
for (String word : wordDict) {      // 2. 遍历原来的列表
    dict.add(word);                 // 3. 一个个加进去
}

// 聪明办法（现在的写法）
Set<String> dict = new HashSet<>(wordDict); // 一步到位
```

想象 `new HashSet<>(...)` 是一个**自动售货机**的投币口。 这个投币口设计得很死板，它形状是圆的，只接受**硬币**（也就是 `List`, `Set` 这种 `Collection` 类型）。

而数组（`String[]`）就像是一张**纸币**。 虽然纸币也是钱，也有价值，但是形状不对，**塞不进去！** 如果你硬塞，机器（编译器）就会报警。

**怎么办？** 你需要找个“兑换机”（适配器），把纸币换成硬币，才能投进去。 这个兑换机在 Java 里就是 `Arrays.asList(...)`。

### 7最长递增子序列（内层j进行遍历择优入取）

**初始化 (`Arrays.fill(dp, 1)`)**：

- 每个数字本身至少可以构成一个长度为 1 的子序列（只有它自己）。这是保底值。

**外层循环 (`i` from 1 to n)**：

- 我们逐个考察数组中的每个数字，试图以它为终点构建序列。

**内层循环 (`j` from 0 to i)**：

- 这是 $O(N^2)$ 的罪魁祸首。我们在扫描历史记录。
- `if (nums[j] < nums[i])`：**接龙条件**。只有前面的数比我小，我才能接在后面。
- `dp[i] = Math.max(dp[i], dp[j] + 1)`：**择优录取**。

### 8乘积最大子数组

### 阶段一：👶 幼儿园直觉理解 (The Intuition)

**目标：** 用“魔法药水与翻转镜”向5岁孩子解释。

想象你在玩一个超级玛丽的游戏，你要吃掉一路上的一排蘑菇来让自己变得越大越好。

这里有两种特殊的蘑菇：

1. **正数蘑菇（比如 2, 3）：** 吃了它，你的体型会**直接翻倍**！比如你现在是 2 米高，吃了“3倍蘑菇”，就变成 6 米高。
2. **负数蘑菇（比如 -2, -5）：** 这是一个“**魔法翻转镜**”。吃了它，你如果原本是正向生长（正数），会瞬间变成倒着长（负数）；但如果你原本就倒着长得很厉害（比如是负很多的数），再照一下镜子，你就瞬间**变回正向，而且超级巨大**（负负得正）！

**为什么要带两个背包？** 因为前面可能有个很坏的“负数蘑菇”把你变成了很小的蚂蚁（也就是一个很大的负数，比如 -100）。一般人可能觉得“完了，我输了”。 但在高手的眼里，这个 -100 是个**宝贝**！ 为什么？因为万一前面还有一个“负数蘑菇”（比如 -2）呢？ 只要那个 -100 再碰到 -2，瞬间就会变成 +200 的超级巨人！

所以，你手里必须时刻抓着两个数：

1. **最大值（maxProd）：** 当前能变成的**最大巨人**。
2. **最小值（minProd）：** 当前能变成的**最惨蚂蚁**（也就是最大的负数，作为**潜力股**留着翻盘用）。

1. 数学建模 (The Equations)

令 $f_{max}[i]$ 为以第 $i$ 个元素结尾的最大乘积，$f_{min}[i]$ 为以第 $i$ 个元素结尾的最小乘积。

状态转移方程如下：



$$f_{max}[i] = \max(nums[i], \quad f_{max}[i-1] \times nums[i], \quad f_{min}[i-1] \times nums[i])$$

$$f_{min}[i] = \min(nums[i], \quad f_{max}[i-1] \times nums[i], \quad f_{min}[i-1] \times nums[i])$$

### 9分割等和子集

### 阶段一：👶 幼儿园直觉理解 (The Intuition)

> **目标**：用“双胞胎分糖果”的比喻，解释为什么要找“总和的一半”。

**场景：双胞胎分家产**

有一堆大小不一的金币（数组 `nums`），两个双胞胎兄弟要分家。 规则是：**必须分得一模一样多**，不能把金币切开，也不能有剩下的。

**第一步：称重（奇偶性判断）** 先把所有金币放在秤上。

- 如果总重是 **11** 斤：别忙活了，怎么分都不可能一样多（因为不能切开）。直接说“不行” (`return false`)。
- 如果总重是 **12** 斤：那每人必须拿 **6** 斤。

**第二步：填满一个背包** 现在问题变简单了：只要**哥哥**能凑齐正好 **6** 斤，剩下的自然就是**弟弟**的（也是 6 斤）。

所以我们只需要盯着哥哥看： 哥哥拿了一个小背包，容量正好是 **6**。 他看着地上的金币，心里想：“我能选几个金币，把这个背包**正好塞满**吗？” 如果能塞满，就成功；塞不满，就失败。

这确实是 0/1 背包问题中最反直觉、但也最精妙的两个点。很多同学在这里会卡很久。

我们把它拆成两个独立的问题来彻底搞懂：

1. **递推公式**：为什么要写成 `dp[j] = dp[j] || dp[j - num]`？
2. **倒序遍历**：为什么要写成 `j--`（倒着走），而不是 `j++`（顺着走）？

------

### 第一部分：递推公式的灵魂



**这句话的中文翻译是：**

> “我要想凑出 `j` 这么大的重量，有两种办法，只要**任意一种能成功**，就算我成功。”

我们把这个公式拆开看：

- **`dp[j]` (等号右边的)**：
  - 代表**“不选这个数字”**。
  - 意思是：**在使用这个新数字 `num` 之前**，我是不是已经能凑出 `j` 了？
  - 如果之前就能凑出（比如靠前面的数字已经凑齐了），那我现在不用动，保持成功状态即可。
- **`dp[j - num]`**：
  - 代表**“选这个数字”**。
  - 意思是：如果我决定把当前的 `num` 放进背包，那我得回头看看，**背包里还剩 `j - num` 空间的时候，能不能填满？**
  - 比如：目标是 10，当前数字是 3。我就要问：“之前能不能凑出 7？”。如果之前能凑出 7，那我加上这个 3，不就正好凑出 10 了吗？
- **`||` (逻辑或)**：
  - 只要上面两条路有一条通，`dp[j]` 就变 `true`。继承之前的成功，或者创造新的成功。

------

### 第二部分：为什么要倒着来 (j--)？（核心难点）

**一句话结论：** **倒着遍历，是为了防止“一个数字被用了多次”。**

我们要解决的是 **0/1 背包**问题（每个数字只能用一次）。 如果不倒着来，就会变成 **完全背包**问题（每个数字可以用无限次）。

#### 💥 现场模拟：如果是正着来 (j++) 会发生什么？

假设我们现在的背包数组 `dp` 只有 `dp[0]` 是 `true`（表示0可以凑出来），其他都是 `false`。 现在来了一个数字：**`num = 2`**。

**❌ 错误的顺时针 (从小到大 j++)：**

1. **当 `j = 2` 时**：
   - `dp[2] = dp[2] || dp[2 - 2]`
   - 查表：`dp[0]` 是 `true`。
   - 结果：**`dp[2]` 变成了 `true`**。（意思是：我有 2 了！）
2. **当 `j = 3` 时**：没变化。
3. **当 `j = 4` 时**：
   - `dp[4] = dp[4] || dp[4 - 2]`
   - 查表：看 `dp[2]`。
   - **出事了！** `dp[2]` 刚刚在第1步里变成了 `true`。
   - 结果：**`dp[4]` 也变成了 `true`**。

**💀 发现了没？** 你手里其实只有 **一个 2**。

- 你用它凑出了 2。
- 然后你又利用刚刚凑出的 2，再加一个 2，凑出了 4。
- **你把这一个 2 用了两次！** 如果数组更长，你会用它凑出 6, 8, 10... 这就变成了“物品无限用”。

------

#### ✅ 现场模拟：如果是倒着来 (j--) 会发生什么？

还是那个场景：`dp[0] = true`，其他全 `false`。 新来的数字：**`num = 2`**。我们从目标 `target`（假设是 6）开始往回算。

1. **当 `j = 6` 时**：
   - `dp[6] = dp[6] || dp[6 - 2]`
   - 查表：`dp[4]` 是 `false`。
   - 结果：`dp[6]` 还是 `false`。
2. **当 `j = 4` 时**：
   - `dp[4] = dp[4] || dp[4 - 2]`
   - 查表：`dp[2]` 是 `false` **（注意！这时候前面的 dp[2] 还没被动过，还是上一轮的状态）**。
   - 结果：`dp[4]` 还是 `false`。
3. **...中间略...**
4. **当 `j = 2` 时**：
   - `dp[2] = dp[2] || dp[2 - 2]`
   - 查表：`dp[0]` 是 `true`。
   - 结果：**`dp[2]` 变成了 `true`**。

**✨ 完美结果**： 这一轮遍历结束，只有 `dp[2]` 变成了 `true`。`dp[4]` 依然是 `false`。我们成功地保证了数字 2 只被使用了一次。

# ❤️所以就是你的大小是用小钱开始，但是背包容量从最大开始算

### 🧱 0/1 背包一维数组的“三大铁律”

#### 1. 外层循环：必须遍历物品 (Items)

> **原则**：`for (int num : nums)` 写在最外面。

- **物理意义**：这代表“**阶段**”。
- **解释**：我们是**逐个**把物品拿到面前，问：“在这个物品加入后，我的所有容量状态 (`dp` 数组) 能怎么更新？”
- **如果不这么做**（比如把容量放在外层）：
  - 你会变成在每一个容量下，都去尝试一遍所有物品。这在 1D 数组下会导致混乱，通常变成了“排列问题”（如爬楼梯、组合总和 IV），而不再是单纯的“集合选择问题”。

#### 2. 内层循环：必须遍历容量 (Capacity)

> **原则**：`for (int j = target; ...)` 写在里面。

- **物理意义**：这代表“**状态**”。
- **解释**：当我们手里拿着第 `i` 个物品时，我们需要更新所有可能的背包容量下的最大价值/可能性。

#### 3. 遍历方向：必须从大到小 (Reverse)

> **原则**：`j--` 倒着走。

- **物理意义**：这代表“**隔离**”。
- **解释**：正如刚才分析的，这是为了确保在使用 `dp[j - num]` 时，读取到的是**上一轮**（即还没放入当前物品时）的数据。

------

### 🧪 实验对照：如果打破规则会变成什么？

为了证明你的总结是多么正确，我们来看看**打破规则**后的后果。这是算法题中很容易混淆的四种变体：

### 10最长有效括号

### 阶段一：👶 幼儿园直觉理解 (The Intuition)

**目标：** 用“搭积木”的比喻解释核心逻辑。

想象你在玩一种特殊的积木，只有两种形状：**左弯 `(`** 和 **右弯 `)`**。我们要找出能拼起来的、**最长的一条连续**积木。

- **规则：** 只有 **右弯 `)`** 才能作为结尾。
- **情况一：** 你手里拿着一个右弯 `)`，回头一看，前一个刚好是左弯 `(`。
  - **动作：** 咔嚓！拼上了！这组长度是 2。
  - **如果前面还有？** 如果这对积木前面已经有一条拼好的长积木，那就把它们**粘在一起**，长度变长。
- **情况二：** 你手里拿着一个右弯 `)`，回头一看，前一个也是右弯 `)`。
  - **动作：** 这说明你可能在包一个“大洋葱”。前一个右弯已经拼好了一段积木。
  - **跳跃检查：** 你要跨过前一个积木的那段长度，去看看**更前面**有没有留着一个孤零零的左弯 `(` 等着你。
  - **如果找到了：** 咔嚓！包住了！长度 = 里面的积木 + 你的外壳(2) + **最左边可能连着的其他积木**。

#### 情况 1：简单配对 `()`

代码：

Java

```
if (s.charAt(i - 1) == '(') {
    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
}
```

- **逻辑：** 遇到了 `...()`。
- **计算：** 这对括号本身贡献 **2** 个长度 + 这一对之前（`i-2` 处）累积的长度。
- **图解：** `... ( )` `   ↑ ↑` ` dp[i-2] + 2`

#### 情况 2：嵌套扩展 `...))` —— 最难的部分

代码：

Java

```
else if (i - 1 - dp[i - 1] >= 0 && s.charAt(i - 1 - dp[i - 1]) == '(')
```

- **场景：** 类似于 `((...))`。当前是 `)`，前一个也是 `)`。
- **逻辑推演：**
  1. `dp[i-1]` 告诉我们，前一个 `)` 已经组成了多长的有效子串。
  2. 我们需要**跳过**这段有效子串，去检查它前面的那个字符。
  3. **跳跃索引计算：** `match_idx = i - 1 - dp[i-1]`。
     - `i-1` 是前一个位置。
     - 减去 `dp[i-1]` 就是跨过中间的有效部分。
  4. **检查：** 如果 `s[match_idx]` 是 `(`，说明我们找到了和当前 `)` 配对的那个开括号！

**状态转移方程：**

Java

```
dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0);
```

这一行代码把**三部分**加在了一起：

1. **`dp[i-1]`**：中间包裹的那段有效长度（洋葱心）。
2. **`2`**：当前这个 `)` 和 跳跃找到的那个 `(` 组成的壳（洋葱皮）。
3. **`dp[i - dp[i-1] - 2]`**：**最关键的一步！** 还要加上**那个匹配左括号之前**的有效长度。这经常被遗忘，导致断链。

**举例说明这第三部分的重要性：** 字符串：`() (())` 计算最后一个 `)` 时：

- `dp[i-1]` (中间的`()`) = 2
- 壳 = 2
- **目前总共 4。**
- 但是！最前面还有一个 `()` 连着呢。
- 通过 `dp[match_idx - 1]` 找到最前面的 2。
- **最终结果：2 + 2 + 2 = 6。**

# 多维数组

### 1不同路径

你就把你【头顶上】格子的数字，和你【左手边】格子的数字加起来

你手里**只有一排存钱罐**（就一行）。 你把这一排存钱罐从第一行搬到第二行，再搬到第三行……

当你把存钱罐放到新的一行时，里面的数字还没变（那是上一行的旧数字，代表**从上面走下来**的路）。 然后你在这个存钱罐里，又塞进了左边那个罐子的数字（代表**从左边走过来**的路）。 **旧数字（上） + 左边新数字（左） = 现在这个格子的总路径数**

### 2路径和最小

**它是啥？** 这是一个在**加权网格**中寻找最优路径的问题。它利用动态规划的思想，将“整体最短路径”分解为“到达每一个格子的最短路径”。

**代码逻辑拆解 (Function)：** 你提供的代码分了三步走（非常典型的边界处理）：

1. **第一列 (`grid[i][0]`)**：
   - 只能一直**往下走**。没有别的选择。
   - 所以：`当前格子值 += 上面格子的累积值`。
2. **第一行 (`grid[0][j]`)**：
   - 只能一直**往右走**。没有别的选择。
   - 所以：`当前格子值 += 左边格子的累积值`。
3. **中间的格子 (`grid[i][j]`)**：
   - 这是**抉择区**。可以从上面来，也可以从左边来。
   - 核心公式：`当前值 += Math.min(上面的累积值, 左边的累积值)`。

# 3最长回文子串

### 阶段一：👶 幼儿园直觉理解 (The Intuition)

**目标：** 用“扔石子”的比喻向5岁孩子解释。

想象平静的湖面上有一排漂浮的小鸭子，每只鸭子身上写着一个字母。我们要找哪一队鸭子是**“对称”**的。

**怎么找呢？** 这就好比往湖里**扔石子**，看波纹怎么扩散。

1. **扔石子（选中心）：** 你站在每一只鸭子头上（或者两只鸭子中间），往水里扔一颗石子。
2. **波纹扩散（往两边看）：** 波纹一圈圈荡开。
   - 如果**左边**波纹碰到的鸭子和**右边**波纹碰到的鸭子长得一样（比如都是 'A'），那就说明这个圈圈是“对称”的，波纹继续变大！
   - 如果不一样（左边是 'A'，右边是 'B'），或者波纹碰到岸边了，波纹就停下了。
3. **比大小：** 你在每个位置都试一次，最后看看哪次扔石子产生的**完整波纹最大**，那就是我们要找的冠军！

**为什么要扔两次？**

- **情况一（单核）：** 石子正好砸在一只鸭子头上（比如 `a b a`，中心是 `b`）。
- **情况二（双核）：** 石子砸在两只鸭子中间的缝隙里（比如 `a b b a`，中心是两个 `b` 之间的缝隙）。

. 技术推演：为什么算长度要 right - left - 1？

看 expandAroundCenter 的最后几行：

Java

```
while (left >= 0 && ... && s.charAt(left) == s.charAt(right)) {
    left--;   // 假如当前是有效回文，left 继续向左
    right++;  // right 继续向右
}
return right - left - 1;
```

- **推演：** 假设字符串是 `"aba"`，中心是 `b` (index 1)。

  - Step 1: left=1, right=1. Match! -> left=0, right=2.
  - Step 2: left=0, right=2. 'a'=='a'. Match! -> left=-1, right=3.
  - Step 3: left=-1 (越界), Loop ends.

- **计算：** 此时 `right` 是 3，`left` 是 -1。

  - 真实长度是 3 (`aba`)。
  - 公式 `right - left - 1` = $3 - (-1) - 1 = 3$。完美！

- **原理：** 因为 `while` 循环结束时，`left` 和 `right` 已经**多走了一步**（走到了不匹配或者越界的位置），所以我们要把这两个“多走的一步”减掉（$Length = (right - 1) - (left + 1) + 1 = right - left - 1$）。

- ### 多走的要中间部分❤️

### 一、 整体思路：擂台赛模式 (The Big Picture)

整个函数的核心逻辑并不是“一次算出结果”，而是**“一边找，一边更新擂主”**。

- **`start` 和 `end` 是什么？** 它们是**“当前的擂主”**。 也就是**“到目前为止，我见过的最长的那个回文串”**的**起始**和**结束**坐标。它们就像挂在墙上的“最高分排行榜”。
- **`i` 循环在干什么？** `i` 是**挑战者**。 它带着每一个位置（字符）来挑战。每走到一个 `i`，我们就以此为中心扩散，算出这个新挑战者的长度 `len`。
- **那段 `if` 代码在干什么？** 这就是**“踢馆”**的过程！ 每次算出一个新长度 `len`，都要和墙上的“老擂主”比一比。如果**新挑战者**比**老擂主**更长，那就撕掉旧榜单，把新的坐标写上去。

------

### 二、 代码逐行“人话”翻译

让我们看着这段代码，把它变成剧情：

Java

```
// 1. 初始化擂主：一开始没人，起点终点都是0
int start = 0, end = 0; 

// 2. 裁判带着测量尺，从头走到尾（遍历每一个字符）
for (int i = 0; i < s.length(); i++) {
    
    // 3. 测量环节：以 i 为中心，看看能扩多远（比如算出 len = 5）
    // (这里省略了具体测量代码)
    int len = ...; 

    // 4. 【核心提问】：踢馆时刻！
    // 翻译：我刚算出来的长度(len)，有没有比墙上挂着的那个旧记录(end - start)更长？
    if (len > end - start) {
        
        // 5. 如果更长，说明破纪录了！
        // 赶紧用刚才学的“数学魔法”，算出新擂主的坐标
        // 并把它们永久刻在 start 和 end 变量里
        start = i - (len - 1) / 2;
        end = i + len / 2;
        
        // 旧的 start/end 被覆盖了，现在的擂主是这个新的长串！
    }
    // 6. 如果没它长？那就什么都不做，start/end 保持不变，还是原来那个最长的。
}

// 7. 比赛结束，把最后留在墙上的那个“最终擂主”截取出来送给用户
return s.substring(start, end + 1);
```

------

### 三、 深度释疑：为什么是 `end + 1`？

最后这一句： `return s.substring(start, end + 1);`

很多同学会问：**为什么要 +1？**

这是 Java 语言的一个“坏习惯”（或者特性）：

- `substring(a, b)` 的规则是：**包含头，不包含尾**（Left-closed, Right-open）。
- 也就是：它会截取 `[a, b)` 这一段。

**举个例子：**

- 字符串：`"a b c d e"`
- 下标：` 0 1 2 3 4`
- 我们要截取 `"b c d"`。
  - 起点 `start` 是 **1** ('b')。
  - 终点 `end` 是 **3** ('d')。
- 如果我们写 `substring(1, 3)`，Java 会给你 `"bc"`（下标1到2），**它把下标3丢掉了！**
- 所以我们必须写 `substring(1, 4)`，也就是 `substring(start, end + 1)`，Java 才会把下标 3 ('d') 也包进去。

### ❤️平局要折腾

### 1. 拆解这个“偷懒”的逻辑

让我们把 `end - start` 换算一下：

- **真实长度 (Old Length)** = `end - start + 1`
- 所以，**代码里的 `end - start`** 其实等于 `真实长度 - 1`

那么，代码里的判断条件 len > end - start 其实就变成了：



$$len > (\text{真实长度} - 1)$$

在**整数**的世界里，**“大于 (Length - 1)”** 和 **“大于等于 Length”** 是完全等价的。

> **举个例子：**
>
> - 旧的擂主长度是 **5**。 `end - start` 就是 **4**。
> - **新挑战者 (len)** 来了：
>   - 如果是 **4**：`4 > 4` (False) -> 不更新。
>   - 如果是 **5** (平局)：`5 > 4` (True) -> **更新！**

### 4最长公共子序列

**1. 状态定义** `int[][] dp = new int[m + 1][n + 1];`

- 为什么是 `m+1` 和 `n+1`？
- 为了处理**空字符串**的情况。`dp[0][j]` 表示 `text1` 是空的，那公共子序列长度自然是 0。这也是“哨兵”思想。

**2. 核心推演 (The Transitions)**

请把 `dp[i][j]` 想象成一个网格上的点。我们要决定这个点的值，只能从**三个方向**看过来：

- **情况 A：字符匹配（命中！）**
  - 逻辑：`text1[i]` 和 `text2[j]` 是同一个字母。
  - 动作：**左上角 + 1**。
  - 代码：`dp[i][j] = dp[i-1][j-1] + 1;`
  - 解释：既然这两个字符配对成功了，那它们就是“这一轮的增量”。我们把它们俩都“消耗”掉，回头看看它俩出现之前的最大长度是多少（即左上角的值），在这个基础上加 1。
- **情况 B：字符不匹配（继承）**
  - 逻辑：这两个字符不一样，没法凑成一对。
  - 动作：**看左边，看上面，选大的**。
  - 代码：`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);`
  - 解释：
    - `dp[i-1][j]` (上面)：意味着我想“扔掉” `text1` 的当前字符，看看能不能保持住之前的战果。
    - `dp[i][j-1]` (左边)：意味着我想“扔掉” `text2` 的当前字符，看看能不能保持住之前的战果。
    - 因为我想要**最长**的，所以我选这两个分支里更强的那个继承下来。

**3. 为什么是 Math.max?** 因为是“子序列”，不要求连续。如果不匹配，我们不能清零（那是求子串的逻辑），我们要**保留历史最好成绩**。

这个问题问到了动态规划（DP）和数组算法中最容易让人“**下标越界**”或“**逻辑错位**”的痛点。

到底什么时候 new int[n+1]？什么时候 new int[n]？

最后是还 dp[n] 还是 dp[n-1]？

不用死记硬背，我为你总结了一套**“物理意义判断法”**。只要搞清楚 `dp[i]` 代表什么，这三个问题迎刃而解。

------

### 第一部分：什么时候用哨兵（Sentinel）？即 `size + 1`

**核心口诀：**

> **只要问题中存在“空状态”有意义，就加哨兵。**

所谓的哨兵，就是 `dp` 数组的第 0 位（`dp[0]` 或 `dp[0][0]`）。

#### 1. 必须加哨兵的情况（最常见）

如果题目涉及**“前 i 个字符”**、**“前 i 个物品”**、**“凑齐 i 元钱”**，请务必开 `n+1` 的空间。

- **字符串问题 (LCS, 编辑距离)**：
  - 两个字符串比对，必须考虑“如果其中一个是空字符串”怎么办。
  - `dp[0][0]` 代表：空字符串 vs 空字符串，匹配长度为 0。
  - `dp[i][j]` 代表：`text1` 的前 `i` 个字符 vs `text2` 的前 `j` 个字符。
  - **数组大小**：`new int[m+1][n+1]`。
- **背包问题 (凑零钱, 分割等和子集)**：
  - 你要凑 `target` 元。
  - 必须考虑“凑 0 元”的情况（什么都不拿，也是一种方案）。
  - `dp[0]` 代表：凑 0 元的方案数/最少硬币数。
  - **数组大小**：`new int[target + 1]`。

#### 2. 不需要加哨兵的情况

如果题目是**“在这个格子上”**、**“以这个元素结尾”**，通常不需要空状态。

- **网格路径 (Unique Paths, Min Path Sum)**：
  - 你一开始就站在 `(0, 0)` 格子上，不存在“站在空虚里”的情况。
  - `dp[i][j]` 直接对应地图 `grid[i][j]` 的那个格子。
  - **数组大小**：`new int[m][n]` （和原图一样大）。
- **最长递增子序列 (LIS)**：
  - `dp[i]` 代表“以 `nums[i]` **结尾**的最长子序列”。
  - 你必须选中 `nums[i]`，不存在“空”的概念。
  - **数组大小**：`new int[n]`。

------

### 第二部分：下标对齐魔法（Off-by-one 处理）

当你使用了哨兵（`size + 1`）时，最让人头疼的是：`dp` 的下标 `i` 和原字符串/数组的下标 `index` 差 1。

**黄金法则：**

> **`dp[i]` 里的 i 是“数量”（第几个），对应原数组下标 `i-1`。**

#### 图解映射关系

假设字符串是 `"ABC"`。

**代码怎么写？**



------

### 第三部分：到底返回 `mn` 还是 `m-1, n-1`？

这完全取决于你**第一部分**是怎么开数组的。

#### 情况 A：开了哨兵 (Size = N + 1) -> 返回 `dp[N]`

> **场景**：LCS、编辑距离、背包问题、零钱兑换。

- **开空间**：`int[] dp = new int[n + 1];`
- **最后一位索引**：`n`。
- **含义**：`dp[n]` 代表“考虑了全部 **n** 个字符/物品/金额”后的结果。
- **返回**：`return dp[n];` (或者二维的 `dp[m][n]`)

#### 情况 B：没开哨兵 (Size = N) -> 返回 `dp[N - 1]`

> **场景**：网格最小路径、打家劫舍 (House Robber)、跳跃游戏 DP 版。

- **开空间**：`int[] dp = new int[n];`
- **最后一位索引**：`n - 1`。
- **含义**：`dp[n-1]` 代表“走到最后一个下标（`n-1`）”时的状态。
- **返回**：`return dp[n - 1];` (或者二维的 `dp[m-1][n-1]`)

------

### ⚡️ 终极速查表 (Cheat Sheet)

为了让你不再纠结，我总结了这个对照表，做题时直接套用：

### 实战演示：一眼定生死

**例子 1：爬楼梯 (Climbing Stairs)**

- **思考**：我要爬 `n` 阶。有没有第 0 阶？有，就是地面。
- **决策**：用哨兵。
- **操作**：`dp = new int[n + 1]`。`dp[0]=1` (在地面也是一种状态)。
- **返回**：`dp[n]` (爬完 n 阶的方法)。

**例子 2：打家劫舍 (House Robber)**

- **思考**：有 `n` 个房子。我要抢到最后一个房子。
- **决策**：不需要哨兵，直接对应房子下标。
- **操作**：`dp = new int[n]`。`dp[i]` 表示抢到第 `i` 个房子的最大金额。
- **返回**：`dp[n-1]`。*(注：有些变种写法也会加哨兵处理前两间房的边界，但物理意义上 `n-1` 是最后一间房)*

总结一句话：

问自己**“0”代表什么？**

- 如果“0”代表**“没有东西/空”** -> **开 N+1，返回 N，用 i-1 取值**。
- 如果“0”代表**“第0号元素/第0行”** -> **开 N，返回 N-1，用 i 取值**。

### 5字符替换

#### 1. 核心定义与状态

$$dp[i][j]$$

 = `word1[0...i-1]` 转换到 `word2[0...j-1]` 的最小操作数。

- **数组大小 `[m+1][n+1]`：**
  - 就像之前的背包问题一样，**第 0 行/列**代表**空字符串**。
  - `dp[i][0]`：把 `word1` 的前 `i` 个字符变成“空”，需要删 `i` 次。
  - `dp[0][j]`：把“空”变成 `word2` 的前 `j` 个字符，需要插 `j` 次。
  - 这就是代码中两个初始化循环的含义。

#### 2. 第一性原理：上帝视角的三选一

当我们在计算 `dp[i][j]` 时，我们只看三个“邻居”：

**代码对应关系（高能预警）：**

Java

```
dp[i][j] = Math.min(
    dp[i - 1][j - 1],  // 邻居 1：左上角
    Math.min(
        dp[i - 1][j],  // 邻居 2：上方
        dp[i][j - 1]   // 邻居 3：左方
    )
) + 1;
```

让我们逐一破解这三个方向代表的物理动作：

- **↖️ 左上角 (`dp[i-1][j-1]`): 替换 (Replace)**
  - *逻辑：* 我们已经把 `word1` 的前 `i-1` 变成了 `word2` 的前 `j-1`。
  - *现在：* 把 `word1` 的第 `i` 个变成 `word2` 的第 `j` 个。
  - *代价：* 如果字符一样，代价+0（直接继承）；如果不一样，代价+1（替换）。
- **⬆️ 上方 (`dp[i-1][j]`): 删除 (Delete)**
  - *逻辑：* `word1` 的前 `i-1` 个字符已经能搞定 `word2` 的前 `j` 个字符了。
  - *现在：* `word1` 多冒出来一个第 `i` 个字符。
  - *动作：* 把它**删掉**。
  - *代价：* 之前的步数 + 1。
- **⬅️ 左方 (`dp[i][j-1]`): 插入 (Insert)**
  - *逻辑：* `word1` 的前 `i` 个字符只能搞定 `word2` 的前 `j-1` 个字符。
  - *现在：* `word2` 多了一个第 `j` 个字符，而 `word1` 已经用光了。
  - *动作：* 强行**插入**一个字符来匹配它。
  - *代价：* 之前的步数 + 1。

#### 3. 索引偏移 (Off-by-one Error)

这里再次出现了你关心的索引问题：

- **代码：** `word1.charAt(i - 1) == word2.charAt(j - 1)`
- **原因：** `dp` 数组从 1 开始代表第一个字符，而字符串 `String` 从 0 开始。
  - `dp[1]` 对应 `String[0]`。
  - `dp[i]` 对应 `String[i-1]`。